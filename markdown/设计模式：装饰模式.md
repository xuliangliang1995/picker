# 装饰模式(`Decorator Pattern`)
![QQ20191231155523.png](https://picker-oss.oss-cn-beijing.aliyuncs.com/20191231/19535fbb67671e2eff940b10f10a3c98.png_target)

装饰（`Decorator`）模式又名包装（`Wrapper`）模式。

装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

## 引言

    装饰模式以对客户端透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

![](https://picker-oss.oss-cn-beijing.aliyuncs.com/20191223/37fd1a503f042892ad3a373bc8abcbc5.png_target)


## 使用场景

1. 需要扩展一个类的功能，或给一个类增加附加责任
2. 需要动态地给一个对象增加功能，这些功能可以动态地撤销。
3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。

## 优点和缺点

### 优点：

1. 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。

   装饰模式允许系统动态地决定 “贴上” 一个需要的 “装饰”， 或者除掉一个不需要的 “装饰” 。 继承关系则不同，继承关系是静态的，它在系统运行前就决定了。

2. 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合。

### 缺点：

    由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。



## 模式的简化

    大多数情况下，装饰模式的实现都比定义中给出的示意性实现要简单。对模式进行简化时需要注意以下的情况。

 1. 一个装饰类的接口必须与被装饰类的接口相容。

 2. 尽量保持 `Component` 作为一个 “轻” 类。

    这个类的责任是为各个 `ConcreteDecorator` 类提供共同的接口，因此它应当着重在提供接口而不是存储数据。在实际工作中，它可以是一个抽象类或是一个具体类。此时，就应当注意不要把太多的逻辑和状态放在 `Component` 类里。

 3. 如果只有一个 `ConcreateComponent` 类而没有抽象的 `Component` 类（接口），那么 `Decorator` 类经常可以是 `ConcreteComponent` 的一个子类。

 4. 如果只有一个（甚至只有两个） `ConcreteDecorator`  类，那么就没有必要建立一个单独的 `Decorator` 类，而可以把 `Decorator` 和 `ConcreteDecorator` 的责任合并成一个类。



## 透明性的要求

    装饰模式对客户端的透明性要求程序不要声明一个 `ConcreteDecorator` 类型的变量，而应当声明一个 `Component`  类型的变量。换言之，下面的做法是对的：

```java
Component c = new ConcreteComponent();
Component c1 = new ConcreteDecorator1(c);
Component c2 = new ConcreteDecorator2(c2);
```

而下面的做法是不对的：

```java
ConcreteComponent c = new ConcreteComponent();
ConcreteDecorator1 c1 = new ConcreteDecorator1(c);
```



## 半透明的装饰模式

    然而，纯粹的装饰模式很难找到。装饰模式的用意是在于不改变接口的前提下，增强所考虑的类的性能。在增强性能的同时，往往需要建立新的公开的方法。
    
    这就导致了大多数的装饰模式的实现都是 “半透明” 的，而不是完全 “透明” 的。
    
    半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能呢。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。
    
    半透明的装饰模式，又叫做退化的装饰模式。



## 与其他模式的关系

##### 适配器模式

    装饰模式和适配器模式都有一个别名，即包装模式，但是这两个模式是很不一样的。适配器模式的用意是要改变所考虑的对象的接口而不是一定改变对象的性能，而装饰模式的用意是要保持接口，从而增强所考虑对象的性能。

##### 策略模式

    装饰模式是将一个东西的表皮换掉，而保持它的内心。策略模式恰好相反，它在保持接口不变的情况下，使具体算法可以互换。
    
    装饰模式的实现要求 `Component` 类尽量地 “轻”， 而策略模式要求抽象策略类尽量的 “重”。

##### 合成模式

    装饰模式常常在合成模式的行为扩展上。使用继承关系扩展合成模式的行为很困难。如果仅仅对抽象构建 `Component` 类还是合成类 `Composite` 类或者树叶 `Leaf` 类使用继承方法，都会导致多态性被破坏。惟一能够保持多态性的方法，便是对所有的三种角色都使用继承关系，而这显然不是很好的方法。
    
    装饰模式是继承关系的替代方案。装饰模式可以动态地位合成模式添加新的行为。