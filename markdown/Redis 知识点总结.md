# `Redis` 知识点总结

![](https://picker-oss.oss-cn-beijing.aliyuncs.com/20191128/2a97b16b5806fb0ca4e69e2bed8aeb25.jpg_target)

#### 1. 什么是 `Redis` ?

`Redis` 全拼为 `REmote DIctionary Server`，即：远程字典服务器。是在内存中以`KV` 结构存储数据的菲关系型数据库。它有如下特点（快、持、多、扩）：

* 基于内存的高性能
* 可选的持久化方案
* 多种数据类型的支持
* 水平扩展的支持

广泛应用于大数据以及实时性要求较高的 `web` 网站。

#### 2.  ` Redis` 支持的数据类型？（5 种）

* `String` 
* `List`
* `Set`
* `Hash`
* `Sorted Set`

#### 3. `Redis` 使用场景

* 缓存系统
* 排行榜
* 计数器
* 分布式 `session`
* 分布式锁
* 消息系统

#### 4. `Redis` 单线程为什么这么快？

* 纯内存操作
* 单线程避免线程切换消耗以及加锁操作
* `I/O` 多路复用模型，非阻塞 `I/O`
* 高效的数据存储结构（`SDS`、`SkipList`等）

#### 5. `Redis` 持久化机制

* `RDB` 定期快照存储
* `AOF` Append-only file

#### 6. 为什么要使用 `Redis` 集群？

* 性能进一步提升
* 存储容量扩展
* 高可用，避免单点故障

#### 7. 什么叫缓存穿透？如何避免？

缓存穿透是指查询一个数据库中不存在的数据，如果从存储层查不到数据则不写入缓存。这就会导致，每次查询不存在的数据，都需要去数据库中查询。如果有人利用不存在的 `key` 频繁攻击我们的应用，数据库压力很大就很有可能挂掉。

解决方案：

（1）布隆过滤器

（2）如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，并设置较短的过期时间。

#### 8. 什么叫缓存击穿？如何避免？

对于一些设置了过期时间的 `key`，如果这些 `key` 可能在某些时间点被超高并发地访问，这个时候就需要考虑 “缓存击穿” 的问题。

当在某个 `key` 刚好过期的时间点，恰好有大量对这个 `key`  的请求过来，这些请求都会从数据库中去加载数据并回设到缓存，可能会导致数据库垮掉。

解决方案：

（1）互斥锁

#### 9. 什么叫缓存雪崩？如何避免？

缓存雪崩是指在某一时间点，有大量的 `key` 同时过期，导致某一时刻大量缓存失效，请求全部转发到数据库，导致数据库挂掉。

解决方案：

（1）失效时间+随机数

#### 10. 什么是缓存与数据库双写一致性问题？

当数据发生更新时，各种情况可能会导致缓存与数据库数据不一致的问题。

理论上，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。

解决方案：

（1）如果严格要求一致性，则保证以下两个步骤串行化即可：

* 读取数据库 + 回设缓存

* 更新数据库 + 删除缓存

（2）极小概率允许不一致，则可以使用 `Cache Aside Pattern`

* 读的时候，先读缓存，缓存没有的话，就读数据库，然后回设缓存。
* 更新的时候，先更新数据库，然后再删除缓存。

#### 11. `Redis` 过期策略

* 定时过期 主动淘汰（对 CPU 不友好）
* 惰性过期 被动淘汰（对内存不友好）
* 定期过期 （折中）

#### 12. `Redis` 内存淘汰策略

* **volatile-lru**：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

* **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰

* **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰

* **allkeys-lru**：从数据集中挑选最近最少使用的数据淘汰

* **allkeys-random**：从数据集中任意选择数据淘汰

* **no-enviction**（驱逐）：禁止驱逐数据

#### 13. `Redis` 对事务的支持

`redis` 对事务的支持目前还比较简单。`redis` 只能保证一个 `client` 发起的事务中的命令可以连 续的执行，而中间不会插入其他 `client` 的命令。 由于 `redis` 是单线程来处理所有 `client` 的请求的所以做到这点是很容易的。一般情况下 `redis` 在接受到一个 `client` 发来的命令后会立即 处理并 返回处理结果，但是当一个 `client` 在一个连接中发出 `multi` 命令时，这个连接会进入 一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一个队列中。当从此连接 受到 `exec` 命令后，`redi`s 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 `client`，然后此连接就 结束事务上下文。

相关命令：

* `multi`
* `exec`
* `discard`
* `watch`：`watch` 命令会监视给定的 `key`，当 `exec` 时候如果监视的 `key` 从调用 `watch` 后发生过变化，则整个事务会失败。`watch` 的 `key` 是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。`exec,discard,unwatch` 都会清除连接中的所有监视。

`redis` 只能保证事务的每个命令连续执行，但是如果事务中的一个命令失败了，并不回滚其他命令。